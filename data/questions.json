{
  "questions": [
    {
      "question": "Какой фреймворк JavaScript является самым популярным?",
      "options": ["Angular", "React", "Svelte", "Vue"],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Какая компания изобрела React?",
      "options": ["Google", "Apple", "Netflix", "Facebook"],
      "correctOption": 3,
      "points": 10
    },
    {
      "question": "Что является основным строительным блоком в приложениях React?",
      "options": ["Components", "Blocks", "Elements", "Effects"],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "Как называется синтаксис, который мы используем для описания пользовательского интерфейса в React components?",
      "options": ["FBJ", "Babel", "JSX", "ES2015"],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "Как происходит естественный поток данных в приложениях React?",
      "options": [
        "От родительских компонентов к дочерним",
        "От дочерний компонентов к родительским",
        "В обе стороны",
        "По усмотрению разработчиков"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "Как передать данные в дочерний компонент?",
      "options": ["State", "Props", "PropTypes", "Parameters"],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Когда следует использовать производное состояние?",
      "options": [
        "Всякий раз, когда состояние не должно вызывать повторный рендеринг",
        "Всякий раз, когда состояние может быть синхронизировано с каким-либо эффектом",
        "Всякий раз, когда состояние должно быть доступно для всех компонентов",
        "Всякий раз, когда состояние может быть вычислено из другой переменной состояния"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "Что запускает повторный рендеринг пользовательского интерфейса в React?",
      "options": [
        "Запуск эффекта",
        "Передача props",
        "Изменение state",
        "Добавление прослушивателей событий к элементам DOM"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "Когда мы непосредственно \"прикасаемся\" к DOM в React?",
      "options": [
        "Когда нам нужно прослушать какое-либо событие",
        "Когда нам нужно изменить пользовательский интерфейс",
        "Когда нам нужно добавить стили",
        "Почти никогда"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "В какой ситуации мы используем обратный вызов для обновления состояния?",
      "options": [
        "Когда обновление состояния будет происходить медленно",
        "Когда обновленное состояние требует большого объема данных",
        "Когда обновление состояния должно происходить быстрее",
        "Когда новое состояние зависит от предыдущего состояния"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "Если мы передадим функцию в useState, когда будет вызвана эта функция?",
      "options": [
        "При каждом повторном рендеринге",
        "Каждый раз, когда мы обновляем состояние",
        "Только при первоначальном рендеринге",
        "При первом обновлении состояния"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "Какой хук использовать для запроса API при первоначальном рендеринге компонента?",
      "options": ["useState", "useEffect", "useRef", "useReducer"],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Какие переменные должны входить в массив зависимостей useEffect?",
      "options": [
        "Обычно их нет",
        "Все наши переменные состояния",
        "Все состояния и реквизиты, на которые ссылается эффект",
        "Все переменные, необходимые для очистки"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "Эффект всегда будет запускаться при первоначальном рендеринге.",
      "options": [
        "Да",
        "Это зависит от массива зависимостей",
        "Нет",
        "В зависимости от кода в эффекте"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "Когда будет запущен эффект, если у него нет массива зависимостей?",
      "options": [
        "Только при монтаже компонента",
        "Только при отключении компонента",
        "При первом повторном отображении компонента",
        "Каждый раз, когда компонент повторно визуализируется"
      ],
      "correctOption": 3,
      "points": 20
    }
  ]
}
